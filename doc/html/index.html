<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Directed Acyclic Graph Frame Scheduler.</title>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"></a>DAGFrameScheduler&#160;<span id="projectnumber">November 2012</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Directed Acyclic Graph Frame Scheduler. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="goal_sec"></a>
Goals</h2>
<p>This library tries to make writing multithreaded software easier by changing the kinds of primitives that multithreaded software is built upon. Several libraries before this have attempted this already. This library is different becuse it focuses on a specific kind of workload and provides the kinds of guarantees that workload needs while sacrificing other guarantees that workload does need. <br/>
 <br/>
 This attempts to provide a multithreading solution for workloads that must be run in many iterations in a given amount of realtime. Games are an ideal example. Every frame a video game, must update physics simulations, make AI decisions, accept/interpret user input, enforce game rules, perform dynamic I/O and render it to the screen all while maintaining a smooth FrameRate and do that while minimizing drain batteries on portable devices (sometimes without even knowing if the device is portable). <br/>
 <br/>
 This library accomplishes those goals by removing the conventional mutlithreading primitives that so many developers have come to fear, loathe or misunderstand. Mutexes, threads, memory fences, thread_local storage, atomic variables, and all the pitfalls that come with them are replaced by a small set of of primitives that provide all the required sophistication a typical multi-threaded application requires. It does this using a new kind of <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>, <a class="el" href="classMezzanine_1_1Threading_1_1DoubleBufferedResource.html">Double Buffering</a>, A strong concept of Dependencies and a <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a> that uses heuristics to decide how to run it all without exposing needless complexity to the application developer.</p>
<h2><a class="anchor" id="overview_sec"></a>
Overview</h2>
<p>The DAGFrameScheduler is a variation on a common multithreaded work queue. It seeks to avoid its pitfalls, such as non-determinism, thread contention and lackluster scalability, while keeping its advantages including simplicity, understandiblity and low overhead. <br/>
 <br/>
 With this algorithm very few if any calls will need to be made to the underlying system for synchronization in the actual work to be performed. Instead, this library will provide limited deterministic ordering of <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> execution through a dependency feature. Having the knowledge that one <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> will complete after another allows for resources to be used without using expensive and complex synchronization mechansisms like <a class="el" href="classMezzanine_1_1Threading_1_1mutex.html">mutexes</a>, semaphores, or even an <a class="el" href="namespaceMezzanine_1_1Threading.html#a6e0664b750836569d08b8b1fc0e1bca7">Atomic Compare And Swap</a>. These primitives are provided to allow use of this library in advanced ways for developers who are already familiar with multithreaded systems. <br/>
 <br/>
 The internal work queue is not changed while a frame is executing. Because it is only read, each thread can pick its own work. Synchronization still needs to occur, but it has been moved onto each <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> it is manages this with atomic CPU operations. Like this, contention is less frequent, occurring only when threads simultaneously attempt to start the same <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>, and it consumes far less time because atomic operations are CPU instructions instead of Operating System calls. This is managed by the library, so individual <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>s do not need to worry synchronization beyond telling each <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> about its data dependencies and making sure all the <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>s added to a <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a>.</p>
<h2><a class="anchor" id="broken_sec"></a>
Broken Algorithms</h2>
<p>To understand why a new multithreading system is needed, it is helpful to look at other methods of threading that have been used in the past, and understand what they lack or how they aren't ideal for the kinds of work this algorithm is is intended for. <br/>
 <br/>
 I will use charts that plot possible resource use of a computer across time. Generally time will run accross the top a resources, usually CPUs will run down one side. <br/>
 <br/>
 These threading models aren't necessarily broken, some of these clearly have a place in software development. None of these are ideal for video games or other tasks that have realtime recurring execution requirements. Many of these require complex algorithms, require subtle knowledge or simply aren't performant enough for realtime environments. </p>
<h3><a class="anchor" id="broken_Single"></a>
Single Threaded</h3>
<p>An application using this threading model is not actually multithreaded at all. However, It has been shown that software can run in a single and get good perfomance. This is benchmark all other threading models get compared too. <br/>
 <br/>
 There is a term, Speedup ( <a href="http://en.wikipedia.org/wiki/Speedup">http://en.wikipedia.org/wiki/Speedup</a> ), which is simply a comparison of the single threaded performance of an algorithm to the mutlithreaded performance. You simply determine how many times more work the multithreaded algorithm does in the same time, or how many times longer the single threaded algorithm takes to the same work. Ideally two threads will be twice as fast (speedup of 2x), and three thread would be three times as fast (3x speedup), and so; this is called linear speedup. In practice there is always some overhead in creating and synchronizing threads, so achieving linear speedup is diffucult. </p>
<div class="image">
<img src="Single.png" alt="Single.png"/>
<div class="caption">
Single Threaded Execution - Fig 1.</div></div>
   <br/>
 <br/>
 The DAGFrameScheduler library tries to tailor the threading model to the problem to minimize that overhead. With a single threaded application one thread does all the work and always wastes every other thread, but there is no overhead <br/>
 <br/>
 </p>
<h3><a class="anchor" id="broken_Unplanned"></a>
Unplanned Thread</h3>
<p>Sometimes someone means well and tries to increase the performance of a single threaded program and tries to add extra threads to increase performance. Sometimes this works, really well, sometimes there is a marginal increase in performance or a significant increase in bugs. If that someone has a good plan then they can usually achieve close to the best speedup possible in the given situation. This is not easy and many cannot do this or do not want to invest the time it would take. If not carefully planned bugs like deadlock ( <a href="http://en.wikipedia.org/wiki/Deadlock">http://en.wikipedia.org/wiki/Deadlock</a> ) and race conditions ( <a href="http://stackoverflow.com/questions/34510/what-is-a-race-condition">http://stackoverflow.com/questions/34510/what-is-a-race-condition</a> ) can be introduced. Unfortunately no amount of testing can replace this careful planning. Without a complete understanding of how multithreaded software is assembled (a plan) it is not possible to prove that multithreaded software will not hang/freeze or that it will produce the correct results. <br/>
 <br/>
 Software with no multithreading plan could have just about any kind of execution behavior. Usually unplanned software performs at least slightly better than single threaded versions of the software, but frequently does not utilize all the available resources. Generally performance does not scale well as unplanned software is run on more processors. Frequently, there is contention for a specific resource and a thread will wait for that resource longer than is actually need. </p>
<div class="image">
<img src="Unplanned.png" alt="Unplanned.png"/>
<div class="caption">
Unplanned Threaded Execution - Fig 2.</div></div>
   <br/>
 <br/>
 The DAGFrameScheduler is carefully planned and completely avoids costly synchronization mechanisms in favor of less costly minimalistic ones. Marking one <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> as dependent on another allows the reordering of <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnits</a> so that some <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> can be executed with no thread waiting or blocking. <br/>
 <br/>
 </p>
<h4><a class="anchor" id="broken_TaskPerThread"></a>
One Task Per Thread</h4>
<p>A common example of poor planning is the creation of one thread for each task in a game. Despite being conceptually simple, performance of systems designed this was is poor due to synchronization and complexities that synchronization requires. </p>
<h3><a class="anchor" id="broken_ConventionWorkQueue"></a>
Convention Work Queue/Thread Pools</h3>
<p>Conventional work queues and thread pools are well known and robust way to increase the throughput of of an application. These are ideal solutions for many systems, but not games. <br/>
 <br/>
 In conventional workqueues all of the work is broken into a number of small thread-safe units. As these units are created they are stuffed into a queue and threads pull out units of work as it completes other units it has started. This simple plan has many advantages. If there is work to do, then at least one thread will be doing some, and usually more threads will be working; this is good for games and the DAGFrameScheduler mimics it. If the kind of work is unknown when the software is written heuristics and runtime decisions can create the kind of units of work that are required. This is not the case with games and the others kinds of software this library caters to, so changes can be made that remove the problems this causes. One such drawback is that a given unit of work never knows if another is running or has completed, and must therefor make some pessimistic assumptions. </p>
<div class="image">
<img src="Threadpool.png" alt="Threadpool.png"/>
<div class="caption">
Convention Work Queue/ThreadPools - Fig 3.</div></div>
   <br/>
 <br/>
 Common synchronization mechanisms like mutexes or semaphores block the thread for an unknown amount of time, and are required by the design of workqueues. There are two times this is required. The first time is whenever a work unit is acquired by a thread, a mutex (or similar) must be used to prevent other threads from modifying the queue as well. This impacts scalability, but can be circumvented to a point. Common ways to work around this try to split up the work queue pre-emptively, or feed the threads work units from varying points in the queue. The DAGFrameScheduler moves the synchronizantion onto each work to greatly reduce the contention as more workunits are added. <br/>
 <br/>
 The other, and less obvious, point of contention that has not be circumvented in a satisfactory way for games is the large of amount of synchronization required between units of work that must communicate. For example, there may be hundreds of thousands of pieces of data that must be passed from a system into a 3d rendering system. Apply mutexes to each would slow execution an impossibly long time (if it didn't introduce deadlock), while more coarse grained lock would prevent large portions of physics and rendering from occurring at the time causing one or both of them to wait/block. A simple solution would be to run physics before graphics, but common work queues do not provide good guarantees in this regard. <br/>
 <br/>
 The DAGFrameScheduler was explicitly designed to provide exactly this guarantee. If the physics <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> is added to the graphics <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> with <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html#aa4aa268eb7fb596308c109f275c8d7b7">AddDependency(WorkUnit*)</a> then it will always be run before the graphics workunit in a given frame. The drawback of this is that it is more difficult to make runtime creation of workunits (It is possible but it cannot be done during any frame execution), but completely removes the locking mechanisms a conventional work queues. The DAGFrameScheduler has traded one useless feature for a useful guarantee.</p>
<h2><a class="anchor" id="algorithm_sec"></a>
The Algorithm</h2>
<p>When first creating the DAGFrameScheduler it was called it "Dagma-CP" because when describing it the phrase "Directed Acyclic Graph Minimal Assembly of Critical Path" if you are in the lucky 1% who knows what all those terms mean they are very descriptive. For rest of us the algorithm tries to determine what is the shortest way to execute the work that must be executed each frame. It does this by assembling a logical graph of work that must done each frame and executing it. Because all the entries in this will have a definite location somewhere between the beginning and end, and will never circle around back to an earlier point this is called an acyclic graph. <br/>
 <br/>
 For scheduling concerns, there are 3 kinds of <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>s. All <a class="el" href="classMezzanine_1_1Threading_1_1MonopolyWorkUnit.html">MonopolyWorkUnit</a>s are expected to monopolize cpu resources at the beginning of each frame. This is ideal when working with other systems, for example a phsyics system like Bullet3D. If the calls to a physics system are wrapped in a <a class="el" href="classMezzanine_1_1Threading_1_1MonopolyWorkUnit.html">MonopolyWorkUnit</a> then it will be given full opportunity to run before the <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>s and <a class="el" href="classMezzanine_1_1Threading_1_1AsynchronousWorkUnit.html">AsynchronousWorkUnit</a>s are run. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>AsynchronousWorkUnit and Work Unit affinity are not completely implemented at this point in time. The automatic thread adjusting hueristic is also not complete.</dd></dl>
<p>Once all the <a class="el" href="classMezzanine_1_1Threading_1_1MonopolyWorkUnit.html">MonopolyWorkUnit</a>s are done then the <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a> class instance spawns or activates a number of threads based on a simple heuristic. Each thread queries the <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a> for the next piece of work that has the most <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>s that depend on it, and in the case of a tie the <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> that takes the longest to execute. Execution length rather than brevity is preferred because it helps keep each thread's execution time consistently short (I will add a few more pictures to describe this clearly). <br/>
 <br/>
 Some work must be run on specific threads, such as calls to underlying devices (for example, graphics cards using Directx or OpenGL). These <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>s are put into a different listing where only the main thread will attempt to execute them. Other than running these, and running these first, the behavior of the main thread is very similar to other threads. Once a <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> has been completed the thread will query the <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a> for more work. Because the <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a> is never modified during a frame there is no need for synchronization with it specifically, this avoids a key point of contention that reduces scaling. Instead the synchronization is performed with each <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> and is an <a class="el" href="namespaceMezzanine_1_1Threading.html#a6e0664b750836569d08b8b1fc0e1bca7">Atomic Compare And Swap</a> operation to maximize performance. <br/>
 <br/>
 Even much of the <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a>'s work is performed in <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>s, such as log aggregation and certain functions that must be performed each frame. <a class="el" href="classMezzanine_1_1Threading_1_1AsynchronousWorkUnit.html">AsynchronousWorkUnit</a>s continue to run in a thread beyond normal scheduling and are intended to will consume fewer CPU resources and more IO resources. For example loading a large file or listening for network traffic. These will be normal <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a>s in most regards and will check on the asynchronous tasks they manage each frame when they run as a normally scheduled. <br/>
 <br/>
 If a thread should run out of work because all the work is completed the frame will pause until it should start the next frame. This pause length is calulated using a runtime configurable value on the <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a>. If a thread has checked every <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> and some are still not executing, but could not be started because of incomplete dependencies the thread will simply iterate over every <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> in the <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a> until the dependencies of one are met and allows one to be executed. This implicitly guarantees that at least one thread will always do work, and if dependencies chains are kept short then it is more likely that several threads will advance. <br/>
 <br/>
 The <a class="el" href="classMezzanine_1_1Threading_1_1WorkUnit.html">WorkUnit</a> classes are designed to be inherited from and inserted into a <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html">FrameScheduler</a> which will manage their lifetime and execute them when requested via <a class="el" href="classMezzanine_1_1Threading_1_1FrameScheduler.html#a93e8f9d384197837fcf8fc0f3c058a5c">FrameScheduler::DoOneFrame()</a>. <br/>
 <br/>
 Insert DAGFramescheduler picture here. <br/>
 <br/>
 This documentation should not be considered complete nor should the algorithm both are still under development. </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 29 2012 23:08:35 for DagFrameScheduler by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1</small></address>
</body>
</html>
